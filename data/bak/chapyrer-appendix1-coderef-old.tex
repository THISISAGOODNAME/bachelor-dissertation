% !Mode:: "TeX:UTF-8"
\chapter{代码列表}

\begin{lstlisting}[
    language={html},
    caption={clang目录结构},
    label={clang-directory-structure},
]

e1.35.0_64bit
|── bugpoint
|── clang
|── clang++
|── clang-3.7
|── clang-check
|── clang-cl
|── clang-format
|── clang-tblgen
|── count
|── diagtool
|── emscripten-version.txt
|── llc
|── lli
|── lli-child-target
|── llvm-PerfectShuffle
|── llvm-ar
|── llvm-as
|── llvm-bcanalyzer
|── llvm-c-test
|── llvm-config
|── llvm-cov
|── llvm-cxxdump
|── llvm-diff
|── llvm-dis
|── llvm-dsymutil
|── llvm-dwarfdump
|── llvm-extract
|── llvm-link
|── llvm-lit
|── llvm-lto
|── llvm-mc
|── llvm-mcmarkup
|── llvm-nm
|── llvm-objdump
|── llvm-pdbdump
|── llvm-profdata
|── llvm-ranlib
|── llvm-readobj
|── llvm-rtdyld
|── llvm-size
|── llvm-stress
|── llvm-symbolizer
|── llvm-tblgen
|── macho-dump
|── not
|── obj2yaml
|── opt
|── optimizer
|── verify-uselistorder
|── yaml-bench
|── yaml2obj

\end{lstlisting}


\begin{lstlisting}[
    language={html},
    caption={emscripten目录结构},
    label={emscripten-directory-structure},
]

1.35.0
├── AUTHORS
├── CONTRIBUTING.md
├── ChangeLog.markdown
├── LICENSE
├── README.md
├── cmake
├── docs
├── em++
├── em++.bat
├── em-config
├── em-config.bat
├── emar
├── emar.bat
├── embuilder.py
├── emcc
├── emcc.bat
├── emcc.py
├── emcmake
├── emcmake.bat
├── emconfigure
├── emconfigure.bat
├── emlink.py
├── emmake
├── emmake.bat
├── emranlib
├── emranlib.bat
├── emrun
├── emrun.bat
├── emscons
├── emscripten-version.txt
├── emscripten.py
├── emscripten.pyc
├── media
├── package.json
├── site
├── src
├── system
├── tests
├── third_party
└── tools

\end{lstlisting}


\begin{lstlisting}[
    language={html},
    caption={lua REPL关键代码},
    label={html-lua-repl},
]

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>lua.vm.js REPL</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="css/bootstrap.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
      }
    </style>
    <link href="css/bootstrap-responsive.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="js/html5shiv.js"></script>
    <![endif]-->

    <!-- codemirror -->
    <script src="js/codemirror.js"></script>
    <link rel="stylesheet" href="css/codemirror.css">
    <script src="js/lua.js"></script>

  </head>

  <body>

    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="lua.vm.js.html">lua.vm.js</a>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li class="active"><a href="repl.html">REPL</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container">

      <div class="hero-unit">
        <h2>Lua REPL(交互式解释器)</h2>
        <p>这是一个 Lua 语言的<a href="http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> . 点击按钮执行编辑区域中的代码. 你也可以编写你自己的lua代码并运行.</p>
      </div>

      <div class="row">
        <div class="span7" border=1>
          <textarea id="mytext">
print('hello' .. ' ' .. 'world!') -- This is Lua!

print(js.global:eval('[0,1,2,3,4,5][3]')) -- Run JS from Lua

-- Interact with the page using Lua

local screen = js.global.screen
print("you haz " .. (screen.width*screen.height) .. " pixels")

local window = js.global -- global object in JS is the window
window:alert("hello from lua!")
window:setTimeout(function() print('hello from lua callback') end, 2500)

local document = js.global.document
print("this window has title '" .. document.title .. "'")

-- call constructors (global, or as properties of other objects)
print("i made an ArrayBuffer of size " .. js.new(js.global.ArrayBuffer, 20).byteLength)
-- print("i made an ArrayBuffer of size " .. js.global.ArrayBuffer:new(20).byteLength)

print("time iz " .. js.global.Date.now()) -- call with no arguments

print('done!')
</textarea>
        </div>
        <div class="span5">
          <h4>output</h4>
          <pre id="output"></pre>
        </div>
      </div>

      <p><a href="#" class="btn btn-primary btn-large " onclick="executeLua(myCodeMirror.getValue(), true); return false" id="the_button">Execute &raquo;</a></p>

      <div class="row-fluid">
        <div class="span">
      </div>

    </div> <!-- /container -->

<script>
// CodeMirror
var myCodeMirror = CodeMirror.fromTextArea(document.getElementById('mytext'));
//myCodeMirror.setSize(screen.width*0.6, screen.height*0.2);
// Execution
var outputElement = document.getElementById('output')
var Module = {
  print: function(x) {
    outputElement.textContent = (outputElement.textContent ? outputElement.textContent + '\n' : '') + x;
  }
};
function executeLua(code, clear) {
  if (clear) {
    outputElement.style.color = null;
    outputElement.textContent = '';
  }
  try {
    L.execute(code);
  } catch(e) {
    outputElement.style.color = "red";
    outputElement.textContent = e.toString();
  }
}
</script>

<script src="../dist/lua.vm.js"></script>

  </body>
</html>
\end{lstlisting}

\begin{lstlisting}[
    language={C++},
    caption={box2d的webIDL文件},
    label={idl-box2d},
]

[NoDelete]
interface b2Contact {
  b2Manifold GetManifold();
  boolean IsTouching();
  void SetEnabled(boolean flag);
  boolean IsEnabled();
  b2Contact GetNext();
  b2Fixture GetFixtureA();
  long GetChildIndexA();
  b2Fixture GetFixtureB();
  long GetChildIndexB();
  void SetFriction(float friction);
  float GetFriction();
  void ResetFriction();
  void SetRestitution(float restitution);
  float GetRestitution();
  void ResetRestitution();
  void SetTangentSpeed(float speed);
  float GetTangentSpeed();
};

interface b2ContactListener {
};

[JSImplementation="b2ContactListener"]
interface JSContactListener {
  void JSContactListener();

  void BeginContact(b2Contact contact);
  void EndContact(b2Contact contact);
  // TODO: Declare another b2ContactListener implementation without PreSolve/PostSolve,
  // for efficiency (otherwise the JS implementations of these functions must get called
  // even if unused).
  void PreSolve(b2Contact contact, [Const] b2Manifold oldManifold);
  void PostSolve(b2Contact contact, [Const] b2ContactImpulse impulse);
};

interface b2World {
  void b2World([Const, Ref] b2Vec2 gravity);
  void SetDestructionListener(b2DestructionListener listener);
  void SetContactFilter(JSContactFilter filter);
  void SetContactListener(JSContactListener listener);
  void SetDebugDraw(b2Draw debugDraw);
  b2Body CreateBody([Const] b2BodyDef def);
  void DestroyBody(b2Body body);
  b2Joint CreateJoint([Const] b2JointDef def);
  void DestroyJoint(b2Joint joint);
  void Step(float timeStep, long velocityIterations, long positionIterations);
  void ClearForces();
  void DrawDebugData();
  void QueryAABB(b2QueryCallback callback, [Ref] b2AABB aabb);
  void RayCast(b2RayCastCallback callback, [Ref] b2Vec2 point1, [Ref] b2Vec2 point2);
  b2Body GetBodyList();
  b2Joint GetJointList();
  b2Contact GetContactList();
  void SetAllowSleeping(boolean flag);
  boolean GetAllowSleeping();
  void SetWarmStarting(boolean flag);
  boolean GetWarmStarting();
  void SetContinuousPhysics(boolean flag);
  boolean GetContinuousPhysics();
  void SetSubStepping(boolean flag);
  boolean GetSubStepping();
  long GetProxyCount();
  long GetBodyCount();
  long GetJointCount();
  long GetContactCount();
  long GetTreeHeight();
  long GetTreeBalance();
  float GetTreeQuality();
  void SetGravity([Ref] b2Vec2 gravity);
  [Value] b2Vec2 GetGravity();
  boolean IsLocked();
  void SetAutoClearForces(boolean flag);
  boolean GetAutoClearForces();
  [Const, Ref] b2Profile GetProfile();
  void Dump();
};

enum b2ShapeType {
  "b2Shape::e_circle",
  "b2Shape::e_edge",
  "b2Shape::e_polygon",
  "b2Shape::e_chain",
  "b2Shape::e_typeCount"
};

interface b2Shape {
  b2ShapeType GetType();
  long GetChildCount();
  boolean TestPoint([Ref] b2Transform xf, [Ref] b2Vec2 p);
  boolean RayCast(b2RayCastOutput output, [Ref] b2RayCastInput input,
                  [Ref] b2Transform transform, long childIndex);
  void ComputeAABB(b2AABB aabb, [Ref] b2Transform xf, long childIndex);
  void ComputeMass(b2MassData massData, float density);

  attribute b2ShapeType m_type;
  attribute float m_radius;
};

interface b2FixtureDef {
  void b2FixtureDef();
  [Const] attribute b2Shape shape;
  attribute any userData;
  attribute float friction;
  attribute float restitution;
  attribute float density;
  attribute boolean isSensor;
  [Value] attribute b2Filter filter;
};

interface b2Fixture {
  b2ShapeType GetType();
  b2Shape GetShape();
  void SetSensor(boolean sensor);
  boolean IsSensor();
  void SetFilterData([Ref] b2Filter filter);
  [Const, Ref] b2Filter GetFilterData();
  void Refilter();
  b2Body GetBody();
  b2Fixture GetNext();
  any GetUserData();
  void SetUserData(any data);
  boolean TestPoint([Ref] b2Vec2 p);
  boolean RayCast(b2RayCastOutput output, [Ref] b2RayCastInput input, long childIndex);
  void GetMassData(b2MassData massData);
  void SetDensity(float density);
  float GetDensity();
  float GetFriction();
  void SetFriction(float friction);
  float GetRestitution();
  void SetRestitution(float restitution);
  [Const, Ref] b2AABB GetAABB(long childIndex);
  void Dump(long bodyIndex);
};

interface b2Transform {
  void b2Transform();
  void b2Transform([Ref] b2Vec2 position, [Ref] b2Rot rotation);
  void SetIdentity();
  void Set([Ref] b2Vec2 position, float angle);
  [Value] attribute b2Vec2 p;
  [Value] attribute b2Rot q;
};


interface b2RayCastCallback {
};
[JSImplementation="b2RayCastCallback"]
interface JSRayCastCallback {
  void JSRayCastCallback();
  float ReportFixture(b2Fixture fixture, [Const, Ref] b2Vec2 point,
                      [Const, Ref] b2Vec2 normal, float fraction);
};

interface b2QueryCallback {
};
[JSImplementation="b2QueryCallback"]
interface JSQueryCallback {
  void JSQueryCallback();
  boolean ReportFixture(b2Fixture fixture);
};

interface b2MassData {
  void b2MassData();
  attribute float mass;
  [Value] attribute b2Vec2 center;
  attribute float I;
};

interface b2Vec2 {
  void b2Vec2();
  void b2Vec2(float x, float y);
  void SetZero();
  void Set(float x, float y);
  [Operator="+="] void op_add([Const, Ref] b2Vec2 v);
  [Operator="-="] void op_sub([Const, Ref] b2Vec2 v);
  [Operator="*="] void op_mul(float s);
  float Length();
  float LengthSquared();
  float Normalize();
  boolean IsValid();
  [Value] b2Vec2 Skew();
  attribute float x;
  attribute float y;
};

interface b2Vec3 {
  void b2Vec3();
  void b2Vec3(float x, float y, float z);
  void SetZero();
  void Set(float x, float y, float z);
  [Operator="+="] void op_add([Const, Ref] b2Vec3 v);
  [Operator="-="] void op_sub([Const, Ref] b2Vec3 v);
  [Operator="*="] void op_mul(float s);
  attribute float x;
  attribute float y;
  attribute float z;
};

[NoDelete]
interface b2Body {
  b2Fixture CreateFixture(b2FixtureDef def);
  b2Fixture CreateFixture(b2Shape shape, float density);
  void DestroyFixture(b2Fixture fixture);
  void SetTransform([Ref] b2Vec2 position, float angle);
  [Const, Ref] b2Transform GetTransform();
  [Const, Ref] b2Vec2 GetPosition();
  float GetAngle();
  [Const, Ref] b2Vec2 GetWorldCenter();
  [Const, Ref] b2Vec2 GetLocalCenter();
  void SetLinearVelocity([Ref] b2Vec2 v);
  [Value] b2Vec2 GetLinearVelocity();
  void SetAngularVelocity(float omega);
  float GetAngularVelocity();
  void ApplyForce([Ref] b2Vec2 force, [Ref] b2Vec2 point, boolean awake);
  void ApplyForceToCenter([Ref] b2Vec2 force, boolean awake);
  void ApplyTorque(float torque, boolean awake);
  void ApplyLinearImpulse([Ref] b2Vec2 impulse, [Ref] b2Vec2 point, boolean awake);
  void ApplyAngularImpulse(float impulse, boolean awake);
  float GetMass();
  float GetInertia();
  void GetMassData(b2MassData data);
  void SetMassData(b2MassData data);
  void ResetMassData();
  [Value] b2Vec2 GetWorldPoint([Ref] b2Vec2 localPoint);
  [Value] b2Vec2 GetWorldVector([Ref] b2Vec2 localVector);
  [Value] b2Vec2 GetLocalPoint([Ref] b2Vec2 worldPoint);
  [Value] b2Vec2 GetLocalVector([Ref] b2Vec2 worldVector);
  [Value] b2Vec2 GetLinearVelocityFromWorldPoint([Ref] b2Vec2 worldPoint);
  [Value] b2Vec2 GetLinearVelocityFromLocalPoint([Ref] b2Vec2 localPoint);
  float GetLinearDamping();
  void SetLinearDamping(float linearDamping);
  float GetAngularDamping();
  void SetAngularDamping(float angularDamping);
  float GetGravityScale();
  void SetGravityScale(float scale);
  void SetType(b2BodyType type);
  b2BodyType GetType();
  void SetBullet(boolean flag);
  boolean IsBullet();
  void SetSleepingAllowed(boolean flag);
  boolean IsSleepingAllowed();
  void SetAwake(boolean flag);
  boolean IsAwake();
  void SetActive(boolean flag);
  boolean IsActive();
  void SetFixedRotation(boolean flag);
  boolean IsFixedRotation();
  b2Fixture GetFixtureList();
  b2JointEdge GetJointList();
  b2ContactEdge GetContactList();
  b2Body GetNext();
  any GetUserData();
  void SetUserData(any data);
  b2World GetWorld();
  void Dump();
};

enum b2BodyType {
  "b2_staticBody",
  "b2_kinematicBody",
  "b2_dynamicBody"
};

interface b2BodyDef {
  void b2BodyDef();

  attribute b2BodyType type;
  [Value] attribute b2Vec2 position;
  attribute float angle;
  [Value] attribute b2Vec2 linearVelocity;
  attribute float angularVelocity;
  attribute float linearDamping;
  attribute float angularDamping;
  attribute boolean allowSleep;
  attribute boolean awake;
  attribute boolean fixedRotation;
  attribute boolean bullet;
  attribute boolean active;
  attribute any userData;
  attribute float gravityScale;
};

interface b2Filter {
  void b2Filter();
  attribute unsigned short categoryBits;
  attribute unsigned short maskBits;
  attribute short groupIndex;
};

interface b2AABB {
  void b2AABB();
  boolean IsValid();
  [Value] b2Vec2 GetCenter();
  [Value] b2Vec2 GetExtents();
  float GetPerimeter();
  void Combine([Ref] b2AABB aabb);
  void Combine([Ref] b2AABB aabb1, [Ref] b2AABB aabb2);
  boolean Contains([Ref] b2AABB aabb);
  boolean RayCast(b2RayCastOutput output, [Ref] b2RayCastInput input);
  [Value] attribute b2Vec2 lowerBound;
  [Value] attribute b2Vec2 upperBound;
};

interface b2CircleShape {
  void b2CircleShape();
  [Value] attribute b2Vec2 m_p;
};

b2CircleShape implements b2Shape;

interface b2EdgeShape {
  void b2EdgeShape();
  void Set([Ref] b2Vec2 v1, [Ref] b2Vec2 v2);

  [Value] attribute b2Vec2 m_vertex1;
  [Value] attribute b2Vec2 m_vertex2;
  [Value] attribute b2Vec2 m_vertex0;
  [Value] attribute b2Vec2 m_vertex3;
  attribute boolean m_hasVertex0;
  attribute boolean m_hasVertex3;
};

b2EdgeShape implements b2Shape;

enum b2JointType {
  "e_unknownJoint",
  "e_revoluteJoint",
  "e_prismaticJoint",
  "e_distanceJoint",
  "e_pulleyJoint",
  "e_mouseJoint",
  "e_gearJoint",
  "e_wheelJoint",
  "e_weldJoint",
  "e_frictionJoint",
  "e_ropeJoint",
  "e_motorJoint"
};

enum b2LimitState {
  "e_inactiveLimit",
  "e_atLowerLimit",
  "e_atUpperLimit",
  "e_equalLimits"
};

interface b2JointDef {
  void b2JointDef();
  attribute b2JointType type;
  attribute any userData;
  attribute b2Body bodyA;
  attribute b2Body bodyB;
  attribute boolean collideConnected;
};

[NoDelete]
interface b2Joint {
  b2JointType GetType();
  b2Body GetBodyA();
  b2Body GetBodyB();
  [Value] b2Vec2 GetAnchorA();
  [Value] b2Vec2 GetAnchorB();
  [Value] b2Vec2 GetReactionForce(float inv_dt);
  float GetReactionTorque(float inv_dt);
  b2Joint GetNext();
  any GetUserData();
  void SetUserData(any data);
  boolean IsActive();
  boolean GetCollideConnected();
  void Dump();
};

interface b2WeldJoint {
  [Const, Ref] b2Vec2 GetLocalAnchorA();
  [Const, Ref] b2Vec2 GetLocalAnchorB();
  void SetFrequency(float hz);
  float GetFrequency();
  void SetDampingRatio(float ratio);
  float GetDampingRatio();
  void Dump();
};

b2WeldJoint implements b2Joint;

interface b2WeldJointDef {
  void b2WeldJointDef();
  void Initialize(b2Body bodyA, b2Body bodyB, [Ref] b2Vec2 anchor);
  [Value] attribute b2Vec2 localAnchorA;
  [Value] attribute b2Vec2 localAnchorB;
  attribute float referenceAngle;
  attribute float frequencyHz;
  attribute float dampingRatio;
};

b2WeldJointDef implements b2JointDef;

interface b2ChainShape {
  void b2ChainShape();
  void Clear();
  void CreateLoop(b2Vec2 vertices, long count);
  void CreateChain(b2Vec2 vertices, long count);
  void SetPrevVertex([Ref] b2Vec2 prevVertex);
  void SetNextVertex([Ref] b2Vec2 nextVertex);
  void GetChildEdge(b2EdgeShape edge, long index);

  attribute b2Vec2 m_vertices;
  attribute long m_count;
  [Value] attribute b2Vec2 m_prevVertex;
  [Value] attribute b2Vec2 m_nextVertex;
  attribute boolean m_hasPrevVertex;
  attribute boolean m_hasNextVertex;
};

b2ChainShape implements b2Shape;

interface b2Color {
  void b2Color();
  void b2Color(float r, float g, float b);
  void Set(float ri, float gi, float bi);

  attribute float r;
  attribute float g;
  attribute float b;
};

interface b2ContactEdge {
  void b2ContactEdge();
  attribute b2Body other;
  attribute b2Contact contact;
  attribute b2ContactEdge prev;
  attribute b2ContactEdge next;
};

enum b2ContactFeatureType {
  "b2ContactFeature::e_vertex",
  "b2ContactFeature::e_face"
};

interface b2ContactFeature {
  attribute octet indexA;
  attribute octet indexB;
  attribute octet typeA;
  attribute octet typeB;
};

interface b2ContactFilter {
};

[JSImplementation="b2ContactFilter"]
interface JSContactFilter {
  void JSContactFilter();
  boolean ShouldCollide(b2Fixture fixtureA, b2Fixture fixtureB);
};

interface b2ContactID {
  [Value] attribute b2ContactFeature cf;
  attribute unsigned long key;
};

interface b2ContactImpulse {
  // TODO: webidl\_binder support for array types.
  // attribute float[] normalImpulses;
  // attribute float[] tangentImpulses;
  attribute long count;
};

interface b2DestructionListener {
};

interface b2DestructionListenerWrapper {
};

[JSImplementation="b2DestructionListenerWrapper"]
interface JSDestructionListener {
  void JSDestructionListener();
  // These methods map the overloaded methods from b2DestructionListener onto differently-named
  // methods, so that it is possible to implement both of them in JS.
  void SayGoodbyeJoint(b2Joint joint);
  void SayGoodbyeFixture(b2Fixture joint);
};

interface b2DistanceJoint {
  [Const, Ref] b2Vec2 GetLocalAnchorA();
  [Const, Ref] b2Vec2 GetLocalAnchorB();
  void SetLength(float length);
  float GetLength();
  void SetFrequency(float hz);
  float GetFrequency();
  void SetDampingRatio(float ratio);
  float GetDampingRatio();
};

b2DistanceJoint implements b2Joint;

interface b2DistanceJointDef {
  void b2DistanceJointDef();
  void Initialize(b2Body bodyA, b2Body bodyB, [Ref] b2Vec2 anchorA, [Ref] b2Vec2 anchorB);
  [Value] attribute b2Vec2 localAnchorA;
  [Value] attribute b2Vec2 localAnchorB;
  attribute float length;
  attribute float frequencyHz;
  attribute float dampingRatio;
};

b2DistanceJointDef implements b2JointDef;

enum b2DrawFlag {
  "b2Draw::e_shapeBit",
  "b2Draw::e_jointBit",
  "b2Draw::e_aabbBit",
  "b2Draw::e_pairBit",
  "b2Draw::e_centerOfMassBit"
};

interface b2Draw {
  void SetFlags(unsigned long flags);
  unsigned long GetFlags();
  void AppendFlags(unsigned long flags);
  void ClearFlags(unsigned long flags);
};

[JSImplementation="b2Draw"]
interface JSDraw {
  void JSDraw();
  void DrawPolygon([Const] b2Vec2 vertices, long vertexCount, [Const, Ref] b2Color color);
  void DrawSolidPolygon([Const] b2Vec2 vertices, long vertexCount, [Const, Ref] b2Color color);
  void DrawCircle([Const, Ref] b2Vec2 center, float radius, [Const, Ref] b2Color color);
  void DrawSolidCircle([Const, Ref] b2Vec2 center, float radius, [Const, Ref] b2Vec2 axis, [Const, Ref] b2Color color);
  void DrawSegment([Const, Ref] b2Vec2 p1, [Const, Ref] b2Vec2 p2, [Const, Ref] b2Color color);
  void DrawTransform([Const, Ref] b2Transform xf);
};

interface b2FrictionJoint {
  [Const, Ref] b2Vec2 GetLocalAnchorA();
  [Const, Ref] b2Vec2 GetLocalAnchorB();
  void SetMaxForce(float force);
  float GetMaxForce();
  void SetMaxTorque(float torque);
  float GetMaxTorque();
};

b2FrictionJoint implements b2Joint;

interface b2FrictionJointDef {
  void b2FrictionJointDef();
  void Initialize(b2Body bodyA, b2Body bodyB, [Ref] b2Vec2 anchor);
  [Value] attribute b2Vec2 localAnchorA;
  [Value] attribute b2Vec2 localAnchorB;
  attribute float maxForce;
  attribute float maxTorque;
};

b2FrictionJointDef implements b2JointDef;

interface b2GearJoint {
  b2Joint GetJoint1();
  b2Joint GetJoint2();
  void SetRatio(float ratio);
  float GetRatio();
};

b2GearJoint implements b2Joint;

interface b2GearJointDef {
  void b2GearJointDef();
  attribute b2Joint joint1;
  attribute b2Joint joint2;
  attribute float ratio;
};

b2GearJointDef implements b2JointDef;

interface b2JointEdge {
  void b2JointEdge();
  attribute b2Body other;
  attribute b2Joint joint;
  attribute b2JointEdge prev;
  attribute b2JointEdge next;
};

enum b2ManifoldType {
  "b2Manifold::e_circles",
  "b2Manifold::e_faceA",
  "b2Manifold::e_faceB"
};

interface b2Manifold {
  void b2Manifold();
  // TODO: webidl\_binder support for array types.
  // [Value] attribute b2ManifoldPoint[] points;
  [Value] attribute b2Vec2 localNormal;
  [Value] attribute b2Vec2 localPoint;
  attribute b2ManifoldType type;
  attribute long pointCount;
};

interface b2ManifoldPoint {
  void b2ManifoldPoint();
  [Value] attribute b2Vec2 localPoint;
  attribute float normalImpulse;
  attribute float tangentImpulse;
  [Value] attribute b2ContactID id;
};

interface b2Mat22 {
  void b2Mat22();
  void b2Mat22([Ref] b2Vec2 c1, [Ref] b2Vec2 c2);
  void b2Mat22(float a11, float a12, float a21, float a22);
  void Set([Ref] b2Vec2 c1, [Ref] b2Vec2 c2);
  void SetIdentity();
  void SetZero();
  [Value] b2Mat22 GetInverse();
  [Value] b2Vec2 Solve([Ref] b2Vec2 b);

  [Value] attribute b2Vec2 ex;
  [Value] attribute b2Vec2 ey;
};

interface b2Mat33 {
  void b2Mat33();
  void b2Mat33([Ref] b2Vec3 c1, [Ref] b2Vec3 c2, [Ref] b2Vec3 c3);
  void SetZero();
  [Value] b2Vec3 Solve33([Ref] b2Vec3 b);
  [Value] b2Vec2 Solve22([Ref] b2Vec2 b);
  void GetInverse22(b2Mat33 M);
  void GetSymInverse33(b2Mat33 M);

  [Value] attribute b2Vec3 ex;
  [Value] attribute b2Vec3 ey;
  [Value] attribute b2Vec3 ez;
};

interface b2MouseJoint {
  void SetTarget([Ref] b2Vec2 target);
  [Const, Ref] b2Vec2 GetTarget();
  void SetMaxForce(float force);
  float GetMaxForce();
  void SetFrequency(float hz);
  float GetFrequency();
  void SetDampingRatio(float ratio);
  float GetDampingRatio();
};

b2MouseJoint implements b2Joint;

interface b2MouseJointDef {
  void b2MouseJointDef();
  [Value] attribute b2Vec2 target;
  attribute float maxForce;
  attribute float frequencyHz;
  attribute float dampingRatio;
};

b2MouseJointDef implements b2JointDef;

interface b2PolygonShape {
  void b2PolygonShape();
  void Set(b2Vec2 vertices, long vertexCount);
  void SetAsBox(float hx, float hy);
  void SetAsBox(float hx, float hy, [Ref] b2Vec2 center, float angle);
  long GetVertexCount();
  [Const, Ref] b2Vec2 GetVertex(long index);
  [Value] attribute b2Vec2 m_centroid;

  // TODO: webidl\_binder support for array types.
  // [Value] attribute b2Vec2[] m\_vertices;
  // [Value] attribute b2Vec2[] m\_normals;

  attribute long m_count;
};

b2PolygonShape implements b2Shape;

interface b2PrismaticJoint {
  [Const, Ref] b2Vec2 GetLocalAnchorA();
  [Const, Ref] b2Vec2 GetLocalAnchorB();
  [Const, Ref] b2Vec2 GetLocalAxisA();
  float GetReferenceAngle();
  float GetJointTranslation();
  float GetJointSpeed();
  boolean IsLimitEnabled();
  void EnableLimit(boolean flag);
  float GetLowerLimit();
  float GetUpperLimit();
  void SetLimits(float lower, float upper);
  boolean IsMotorEnabled();
  void EnableMotor(boolean flag);
  void SetMotorSpeed(float speed);
  float GetMotorSpeed();
  void SetMaxMotorForce(float force);
  float GetMaxMotorForce();
  float GetMotorForce(float inv_dt);
};

b2PrismaticJoint implements b2Joint;

interface b2PrismaticJointDef {
  void b2PrismaticJointDef();
  void Initialize(b2Body bodyA, b2Body bodyB, [Ref] b2Vec2 anchor, [Ref] b2Vec2 axis);
  [Value] attribute b2Vec2 localAnchorA;
  [Value] attribute b2Vec2 localAnchorB;
  [Value] attribute b2Vec2 localAxisA;
  attribute float referenceAngle;
  attribute boolean enableLimit;
  attribute float lowerTranslation;
  attribute float upperTranslation;
  attribute boolean enableMotor;
  attribute float maxMotorForce;
  attribute float motorSpeed;
};

b2PrismaticJointDef implements b2JointDef;

interface b2Profile {
  attribute float step;
  attribute float collide;
  attribute float solve;
  attribute float solveInit;
  attribute float solveVelocity;
  attribute float solvePosition;
  attribute float broadphase;
  attribute float solveTOI;
};

interface b2PulleyJoint {
  [Value] b2Vec2 GetGroundAnchorA();
  [Value] b2Vec2 GetGroundAnchorB();
  float GetLengthA();
  float GetLengthB();
  float GetRatio();
  float GetCurrentLengthA();
  float GetCurrentLengthB();
};

b2PulleyJoint implements b2Joint;

interface b2PulleyJointDef {
  void b2PulleyJointDef();
  void Initialize(b2Body bodyA, b2Body bodyB, [Ref] b2Vec2 groundAnchorA, [Ref] b2Vec2 groundAnchorB,
                  [Ref] b2Vec2 anchorA, [Ref] b2Vec2 anchorB, float ratio);
  [Value] attribute b2Vec2 groundAnchorA;
  [Value] attribute b2Vec2 groundAnchorB;
  [Value] attribute b2Vec2 localAnchorA;
  [Value] attribute b2Vec2 localAnchorB;
  attribute float lengthA;
  attribute float lengthB;
  attribute float ratio;
};

b2PulleyJointDef implements b2JointDef;


interface b2RayCastInput {
  [Value] attribute b2Vec2 p1;
  [Value] attribute b2Vec2 p2;
  attribute float maxFraction;
};

interface b2RayCastOutput {
  [Value] attribute b2Vec2 normal;
  attribute float fraction;
};

interface b2RevoluteJoint {
  [Const, Ref] b2Vec2 GetLocalAnchorA();
  [Const, Ref] b2Vec2 GetLocalAnchorB();
  float GetReferenceAngle();
  float GetJointAngle();
  float GetJointSpeed();
  boolean IsLimitEnabled();
  void EnableLimit(boolean flag);
  float GetLowerLimit();
  float GetUpperLimit();
  void SetLimits(float lower, float upper);
  boolean IsMotorEnabled();
  void EnableMotor(boolean flag);
  void SetMotorSpeed(float speed);
  float GetMotorSpeed();
  void SetMaxMotorTorque(float torque);
  float GetMaxMotorTorque();
  float GetMotorTorque(float inv_dt);
};

b2RevoluteJoint implements b2Joint;

interface b2RevoluteJointDef {
  void b2RevoluteJointDef();
  void Initialize(b2Body bodyA, b2Body bodyB, [Ref] b2Vec2 anchor);
  [Value] attribute b2Vec2 localAnchorA;
  [Value] attribute b2Vec2 localAnchorB;
  attribute float referenceAngle;
  attribute boolean enableLimit;
  attribute float lowerAngle;
  attribute float upperAngle;
  attribute boolean enableMotor;
  attribute float motorSpeed;
  attribute float maxMotorTorque;
};

b2RevoluteJointDef implements b2JointDef;

interface b2RopeJoint {
  [Const, Ref] b2Vec2 GetLocalAnchorA();
  [Const, Ref] b2Vec2 GetLocalAnchorB();
  void SetMaxLength(float length);
  float GetMaxLength();
  b2LimitState GetLimitState();
};

b2RopeJoint implements b2Joint;

interface b2RopeJointDef {
  void b2RopeJointDef();
  [Value] attribute b2Vec2 localAnchorA;
  [Value] attribute b2Vec2 localAnchorB;
  attribute float maxLength;
};
b2RopeJointDef implements b2JointDef;

interface b2Rot {
  void b2Rot();
  void b2Rot(float angle);
  void Set(float angle);
  void SetIdentity();
  float GetAngle();
  [Value] b2Vec2 GetXAxis();
  [Value] b2Vec2 GetYAxis();
  attribute float s;
  attribute float c;
};

interface b2WheelJoint {
  [Const, Ref] b2Vec2 GetLocalAnchorA();
  [Const, Ref] b2Vec2 GetLocalAnchorB();
  [Const, Ref] b2Vec2 GetLocalAxisA();
  float GetJointTranslation();
  float GetJointSpeed();
  boolean IsMotorEnabled();
  void EnableMotor(boolean flag);
  void SetMotorSpeed(float speed);
  float GetMotorSpeed();
  void SetMaxMotorTorque(float torque);
  float GetMaxMotorTorque();
  float GetMotorTorque(float inv_dt);
  void SetSpringFrequencyHz(float hz);
  float GetSpringFrequencyHz();
  void SetSpringDampingRatio(float ratio);
  float GetSpringDampingRatio();
};

b2WheelJoint implements b2Joint;

interface b2WheelJointDef {
  void b2WheelJointDef();
  void Initialize(b2Body bodyA, b2Body bodyB, [Ref] b2Vec2 anchor, [Ref] b2Vec2 axis);
  [Value] attribute b2Vec2 localAnchorA;
  [Value] attribute b2Vec2 localAnchorB;
  [Value] attribute b2Vec2 localAxisA;
  attribute boolean enableMotor;
  attribute float maxMotorTorque;
  attribute float motorSpeed;
  attribute float frequencyHz;
  attribute float dampingRatio;
};

b2WheelJointDef implements b2JointDef;

interface b2MotorJoint {
  void SetLinearOffset([Ref] b2Vec2 linearOffset);
  [Const, Ref] b2Vec2 GetLinearOffset();
  void SetAngularOffset(float angularOffset);
  float GetAngularOffset();
  void SetMaxForce(float force);
  float GetMaxForce();
  void SetMaxTorque(float torque);
  float GetMaxTorque();
  void SetCorrectionFactor(float factor);
  float GetCorrectionFactor();

};

b2MotorJoint implements b2Joint;

interface b2MotorJointDef {
  void b2MotorJointDef();
  void Initialize(b2Body bodyA, b2Body bodyB);
  [Value] attribute b2Vec2 linearOffset;
  attribute float angularOffset;
  attribute float maxForce;
  attribute float maxTorque;
  attribute float correctionFactor;
};

b2MotorJointDef implements b2JointDef;

\end{lstlisting}

\begin{lstlisting}[
    language={C++},
    caption={bullet物理引擎的IDL文件},
    label={idl-bullet},
]

// Linear Math

interface btVector3 {
  void btVector3();
  void btVector3(float x, float y, float z);
  float length();
  float x();
  float y();
  float z();
  void setX(float x);
  void setY(float y);
  void setZ(float z);
  void setValue(float x, float y, float z);
  void normalize();
  float dot([Ref] btVector3 v);
  [Operator="*=", Ref] btVector3 op_mul(float x);
  [Operator="+=", Ref] btVector3 op_add([Ref] btVector3 v);
  [Operator="-=", Ref] btVector3 op_sub([Ref] btVector3 v);
};

interface btVector4 {
  void btVector4();
  void btVector4(float x, float y, float z, float w);
  float w();
  void setValue(float x, float y, float z, float w);
};
btVector4 implements btVector3;

interface btQuadWord {
  float x();
  float y();
  float z();
  float w();
  void setX(float x);
  void setY(float y);
  void setZ(float z);
  void setW(float w);
};

interface btQuaternion {
  void btQuaternion(float x, float y, float z, float w);
  void setValue(float x, float y, float z, float w);
  void setEulerZYX(float z, float y, float x);
  void normalize();
};
btQuaternion implements btQuadWord;

interface btMatrix3x3 {
  void setEulerZYX(float ex, float ey, float ez);
  void getRotation([Ref] btQuaternion q);
  [Value] btVector3 getRow(long y);
};

interface btTransform {
  void btTransform();
  void btTransform([Ref] btQuaternion q, [Ref] btVector3 v);

  void setIdentity();
  void setOrigin([Ref] btVector3 origin);
  void setRotation([Ref] btQuaternion rotation);
  [Ref] btVector3 getOrigin();
  [Value] btQuaternion getRotation();
  [Ref] btMatrix3x3 getBasis();
};

interface btMotionState {
  void getWorldTransform([Ref] btTransform worldTrans);
  void setWorldTransform([Ref] btTransform worldTrans);
};

interface btDefaultMotionState {
  void btDefaultMotionState([Ref] optional btTransform startTrans, [Ref] optional btTransform centerOfMassOffset);
  [Value] attribute btTransform m_graphicsWorldTrans;
};
btDefaultMotionState implements btMotionState;

// Collision

interface btCollisionObject {
  void setAnisotropicFriction([Const, Ref] btVector3 anisotropicFriction, long frictionMode);
  btCollisionShape getCollisionShape();
  void setContactProcessingThreshold(float contactProcessingThreshold);
  void setActivationState(long newState);
  void forceActivationState(long newState);
  void activate(optional boolean forceActivation);
  boolean isActive();
  boolean isKinematicObject();
  void setRestitution(float rest);
  void setFriction(float frict);
  void setRollingFriction(float frict);
  [Ref] btTransform getWorldTransform();
  long getCollisionFlags();
  void setCollisionFlags(long flags);
  void setWorldTransform ([Const,Ref] btTransform worldTrans);
  void setCollisionShape (btCollisionShape collisionShape);
  void setCcdMotionThreshold (float ccdMotionThreshold);
  void setCcdSweptSphereRadius (float radius);
  long getUserIndex();
  void setUserIndex(long index);
  VoidPtr getUserPointer();
  void setUserPointer(VoidPtr userPointer);
};

[NoDelete]
interface btCollisionObjectWrapper {
};

[Prefix="btCollisionWorld::"]
interface RayResultCallback {
  // abstract base class, no constructor
  boolean hasHit();
  attribute short m_collisionFilterGroup;
  attribute short m_collisionFilterMask;
  [Const] attribute btCollisionObject m_collisionObject;
};

[Prefix="btCollisionWorld::"]
interface ClosestRayResultCallback {
  void ClosestRayResultCallback([Const, Ref] btVector3 from, [Const, Ref] btVector3 to);

  [Value] attribute btVector3 m_rayFromWorld;
  [Value] attribute btVector3 m_rayToWorld;
  [Value] attribute btVector3 m_hitNormalWorld;
  [Value] attribute btVector3 m_hitPointWorld;
};
ClosestRayResultCallback implements RayResultCallback;

interface btManifoldPoint {
  [Const, Ref] btVector3 getPositionWorldOnA();
  [Const, Ref] btVector3 getPositionWorldOnB();
  [Const] double getAppliedImpulse();
  [Const] double getDistance();
  [Value] attribute btVector3 m_localPointA;
  [Value] attribute btVector3 m_localPointB;
  [Value] attribute btVector3 m_positionWorldOnB;
  [Value] attribute btVector3 m_positionWorldOnA;
  [Value] attribute btVector3 m_normalWorldOnB;
};

[Prefix="btCollisionWorld::"]
interface ContactResultCallback {
  float addSingleResult([Ref] btManifoldPoint cp, [Const] btCollisionObjectWrapper colObj0Wrap, long partId0, long index0, [Const] btCollisionObjectWrapper colObj1Wrap, long partId1, long index1);
};

[JSImplementation="ContactResultCallback"]
interface ConcreteContactResultCallback {
  void ConcreteContactResultCallback();
  float addSingleResult([Ref] btManifoldPoint cp, [Const] btCollisionObjectWrapper colObj0Wrap, long partId0, long index0, [Const] btCollisionObjectWrapper colObj1Wrap, long partId1, long index1);
};

[Prefix="btCollisionWorld::"]
interface LocalShapeInfo {
    attribute long m_shapePart;
    attribute long m_triangleIndex;
 };

[Prefix="btCollisionWorld::"]
interface LocalConvexResult  {
  void LocalConvexResult([Const] btCollisionObject hitCollisionObject, LocalShapeInfo localShapeInfo, [Const, Ref] btVector3 hitNormalLocal, [Const, Ref] btVector3 hitPointLocal, float hitFraction);
  [Const] attribute btCollisionObject m_hitCollisionObject;
  attribute LocalShapeInfo m_localShapeInfo;
  [Value] attribute btVector3 m_hitNormalLocal;
  [Value] attribute btVector3 m_hitPointLocal;
  attribute float m_hitFraction;
};

[Prefix="btCollisionWorld::"]
interface ConvexResultCallback {
  // abstract base class, no constructor
  boolean hasHit();
  attribute short m_collisionFilterGroup;
  attribute short m_collisionFilterMask;
  attribute float m_closestHitFraction;
};

[Prefix="btCollisionWorld::"]
interface ClosestConvexResultCallback {
  void ClosestConvexResultCallback([Const, Ref] btVector3 convexFromWorld, [Const, Ref] btVector3 convexToWorld);

  [Value] attribute btVector3 m_convexFromWorld;
  [Value] attribute btVector3 m_convexToWorld;
  [Value] attribute btVector3 m_hitNormalWorld;
  [Value] attribute btVector3 m_hitPointWorld;
};
ClosestConvexResultCallback implements ConvexResultCallback;

interface btCollisionShape {
  void setLocalScaling([Const, Ref] btVector3 scaling);
  void calculateLocalInertia(float mass, [Ref] btVector3 inertia);
  void setMargin(float margin);
  float getMargin();
};

interface btConvexShape {
};
btConvexShape implements btCollisionShape;

interface btConvexTriangleMeshShape {
  void btConvexTriangleMeshShape(btStridingMeshInterface meshInterface, optional boolean calcAabb);
};
btConvexTriangleMeshShape implements btConvexShape;

interface btBoxShape {
  void btBoxShape([Ref] btVector3 boxHalfExtents);
  void setMargin(float margin);
  float getMargin();
};
btBoxShape implements btCollisionShape;

interface btCapsuleShape {
  void btCapsuleShape(float radius, float height);
  void setMargin(float margin);
  float getMargin();
};
btCapsuleShape implements btCollisionShape;

interface btCapsuleShapeX {
  void btCapsuleShapeX(float radius, float height);
  void setMargin(float margin);
  float getMargin();
};
btCapsuleShapeX implements btCapsuleShape;

interface btCapsuleShapeZ {
  void btCapsuleShapeZ(float radius, float height);
  void setMargin(float margin);
  float getMargin();
};
btCapsuleShapeZ implements btCapsuleShape;

interface btCylinderShape {
  void btCylinderShape([Ref] btVector3 halfExtents);
  void setMargin(float margin);
  float getMargin();
};
btCylinderShape implements btCollisionShape;

interface btCylinderShapeX {
  void btCylinderShapeX([Ref] btVector3 halfExtents);
  void setMargin(float margin);
  float getMargin();
};
btCylinderShapeX implements btCylinderShape;

interface btCylinderShapeZ {
  void btCylinderShapeZ([Ref] btVector3 halfExtents);
  void setMargin(float margin);
  float getMargin();
};
btCylinderShapeZ implements btCylinderShape;

interface btSphereShape {
  void btSphereShape(float radius);
  void setMargin(float margin);
  float getMargin();
};
btSphereShape implements btCollisionShape;

interface btConeShape {
  void btConeShape(float radius, float height);
};
btConeShape implements btCollisionShape;

interface btConvexHullShape {
  void btConvexHullShape();
  void addPoint([Const, Ref] btVector3 point, optional boolean recalculateLocalAABB);
  void setMargin(float margin);
  float getMargin();
};
btConvexHullShape implements btCollisionShape;

interface btConeShapeX {
  void btConeShapeX(float radius, float height);
};
btConeShapeX implements btConeShape;

interface btConeShapeZ {
  void btConeShapeZ(float radius, float height);
};
btConeShapeZ implements btConeShape;

interface btCompoundShape {
  void btCompoundShape(optional boolean enableDynamicAabbTree);
  void addChildShape([Const, Ref] btTransform localTransform, btCollisionShape shape);
  void removeChildShapeByIndex(long childShapeindex);
  [Const] long getNumChildShapes();
  btCollisionShape getChildShape(long index);
  void setMargin(float margin);
  float getMargin();
};
btCompoundShape implements btCollisionShape;

interface btStridingMeshInterface {
};

interface btTriangleMesh {
  void btTriangleMesh(optional boolean use32bitIndices, optional boolean use4componentVertices);
  void addTriangle([Const, Ref] btVector3 vertex0, [Const, Ref] btVector3 vertex1, [Const, Ref] btVector3 vertex2, optional boolean removeDuplicateVertices);
};
btTriangleMesh implements btStridingMeshInterface;

enum PHY_ScalarType {
    "PHY_FLOAT",
    "PHY_DOUBLE",
    "PHY_INTEGER",
    "PHY_SHORT",
    "PHY_FIXEDPOINT88",
    "PHY_UCHAR"
};

interface btConcaveShape {
};
btConcaveShape implements btCollisionShape;

interface btStaticPlaneShape {
  void btStaticPlaneShape([Const, Ref] btVector3 planeNormal, float planeConstant);
};
btStaticPlaneShape implements btConcaveShape;

interface btTriangleMeshShape {
};
btTriangleMeshShape implements btConcaveShape;

interface btBvhTriangleMeshShape {
  void btBvhTriangleMeshShape(btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, optional boolean buildBvh);
};
btBvhTriangleMeshShape implements btTriangleMeshShape;

interface btHeightfieldTerrainShape {
    void btHeightfieldTerrainShape(long heightStickWidth, long heightStickLength, VoidPtr heightfieldData, float heightScale, float minHeight, float maxHeight, long upAxis, PHY_ScalarType hdt, boolean flipQuadEdges);
    void setMargin(float margin);
    float getMargin();
};
btHeightfieldTerrainShape implements btConcaveShape;

interface btDefaultCollisionConstructionInfo {
  void btDefaultCollisionConstructionInfo();
};

interface btDefaultCollisionConfiguration {
  void btDefaultCollisionConfiguration([Ref] optional btDefaultCollisionConstructionInfo info);
};

interface btPersistentManifold {
  void btPersistentManifold();
  [Const] btCollisionObject getBody0();
  [Const] btCollisionObject getBody1();
  long getNumContacts();
  [Ref] btManifoldPoint getContactPoint(long index);
};

interface btDispatcher {
  long getNumManifolds();
  btPersistentManifold getManifoldByIndexInternal(long index);
};

interface btCollisionDispatcher {
  void btCollisionDispatcher(btDefaultCollisionConfiguration conf);
};
btCollisionDispatcher implements btDispatcher;

interface btOverlappingPairCallback {
};

interface btOverlappingPairCache {
  void setInternalGhostPairCallback(btOverlappingPairCallback ghostPairCallback);
};

interface btAxisSweep3 {
  void btAxisSweep3([Ref] btVector3 worldAabbMin, [Ref] btVector3 worldAabbMax, optional long maxHandles, optional btOverlappingPairCache pairCache, optional boolean disableRaycastAccelerator);
};

interface btBroadphaseInterface {
};

interface btCollisionConfiguration {
};

interface btDbvtBroadphase {
  void btDbvtBroadphase();
};


// Dynamics

[Prefix="btRigidBody::"]
interface btRigidBodyConstructionInfo {
  void btRigidBodyConstructionInfo(float mass, btMotionState motionState, btCollisionShape collisionShape, [Ref] optional btVector3 localInertia);
  attribute float m_linearDamping;
  attribute float m_angularDamping;
  attribute float m_friction;
  attribute float m_rollingFriction;
  attribute float m_restitution;
  attribute float m_linearSleepingThreshold;
  attribute float m_angularSleepingThreshold;
  attribute boolean m_additionalDamping;
  attribute float m_additionalDampingFactor;
  attribute float m_additionalLinearDampingThresholdSqr;
  attribute float m_additionalAngularDampingThresholdSqr;
  attribute float m_additionalAngularDampingFactor;
};

interface btRigidBody {
  void btRigidBody([Const, Ref] btRigidBodyConstructionInfo constructionInfo);

  [Const, Ref] btTransform getCenterOfMassTransform();
  void setCenterOfMassTransform([Const, Ref] btTransform xform);
  void setSleepingThresholds(float linear, float angular);
  void setDamping(float lin_damping, float ang_damping);
  void setMassProps(float mass, [Const, Ref] btVector3 inertia);
  void setLinearFactor([Const, Ref] btVector3 linearFactor);
  void applyTorque([Const, Ref] btVector3 torque);
  void applyLocalTorque([Const, Ref] btVector3 torque);
  void applyForce([Const, Ref] btVector3 force, [Const, Ref] btVector3 rel_pos);
  void applyCentralForce([Const, Ref] btVector3 force);
  void applyCentralLocalForce([Const, Ref] btVector3 force);
  void applyTorqueImpulse([Const, Ref] btVector3 torque);
  void applyImpulse([Const, Ref] btVector3 impulse, [Const, Ref] btVector3 rel_pos);
  void applyCentralImpulse([Const, Ref] btVector3 impulse);
  void updateInertiaTensor();
  [Const, Ref] btVector3 getLinearVelocity();
  [Const, Ref] btVector3 getAngularVelocity();
  void setLinearVelocity([Const, Ref] btVector3 lin_vel);
  void setAngularVelocity([Const, Ref] btVector3 ang_vel);
  btMotionState getMotionState();
  void setMotionState(btMotionState motionState);
  void setAngularFactor([Const, Ref] btVector3 angularFactor);
  btRigidBody upcast([Const] btCollisionObject colObj);
};
btRigidBody implements btCollisionObject;

interface btConstraintSetting {
  void btConstraintSetting();
  attribute float m_tau;
  attribute float m_damping;
  attribute float m_impulseClamp;
};

interface btTypedConstraint {
  void enableFeedback(boolean needsFeedback);
  [Const] float getBreakingImpulseThreshold();
  void setBreakingImpulseThreshold([Const] float threshold);
};

interface btPoint2PointConstraint {
  void btPoint2PointConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btVector3 pivotInA, [Ref] btVector3 pivotInB);
  void btPoint2PointConstraint([Ref] btRigidBody rbA, [Ref] btVector3 pivotInA);
  void setPivotA([Const, Ref] btVector3 pivotA);
  void setPivotB([Const, Ref] btVector3 pivotB);
  [Const, Ref] btVector3 getPivotInA();
  [Const, Ref] btVector3 getPivotInB();

  [Value] attribute btConstraintSetting m_setting;
};
btPoint2PointConstraint implements btTypedConstraint;

interface btGeneric6DofConstraint {
  void btGeneric6DofConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btTransform frameInA, [Ref] btTransform frameInB, boolean useLinearFrameReferenceFrameA);
  void btGeneric6DofConstraint([Ref] btRigidBody rbB, [Ref] btTransform frameInB, boolean useLinearFrameReferenceFrameB);
  void setLinearLowerLimit([Const, Ref] btVector3 linearLower);
  void setLinearUpperLimit([Const, Ref] btVector3 linearUpper);
  void setAngularLowerLimit([Const, Ref] btVector3 angularLower);
  void setAngularUpperLimit([Const, Ref] btVector3 angularUpper);
};
btGeneric6DofConstraint implements btTypedConstraint;

interface btGeneric6DofSpringConstraint {
  void btGeneric6DofSpringConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btTransform frameInA, [Ref] btTransform frameInB, boolean useLinearFrameReferenceFrameA);
  void btGeneric6DofSpringConstraint([Ref] btRigidBody rbB, [Ref] btTransform frameInB, boolean useLinearFrameReferenceFrameB);
  void enableSpring(long index, boolean onOff);
  void setStiffness(long index, float stiffness);
  void setDamping(long index, float damping);
};
btGeneric6DofSpringConstraint implements btGeneric6DofConstraint;

interface btSequentialImpulseConstraintSolver {
  void btSequentialImpulseConstraintSolver();
};

interface btConeTwistConstraint {
  void btConeTwistConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btTransform rbAFrame, [Ref] btTransform rbBFrame);
  void btConeTwistConstraint([Ref] btRigidBody rbA, [Ref] btTransform rbAFrame);

  void setLimit(long limitIndex, float limitValue);
  void setAngularOnly(boolean angularOnly);
  void setDamping(float damping);
  void enableMotor(boolean b);
  void setMaxMotorImpulse(float maxMotorImpulse);
  void setMaxMotorImpulseNormalized(float maxMotorImpulse);
  void setMotorTarget([Const,Ref] btQuaternion q);
  void setMotorTargetInConstraintSpace([Const,Ref] btQuaternion q);
};
btConeTwistConstraint implements btTypedConstraint;

interface btHingeConstraint {
  void btHingeConstraint ([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btVector3 pivotInA, [Ref] btVector3 pivotInB, [Ref] btVector3 axisInA, [Ref] btVector3 axisInB, optional boolean useReferenceFrameA);
  //void btHingeConstraint ([Ref] btRigidBody rbA, [Ref] btVector3 pivotInA, [Ref] btVector3 axisInA, optional boolean useReferenceFrameA);
  void btHingeConstraint ([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btTransform rbAFrame, [Ref] btTransform rbBFrame, optional boolean useReferenceFrameA);
  void btHingeConstraint ([Ref] btRigidBody rbA, [Ref] btTransform rbAFrame, optional boolean useReferenceFrameA);

  void setLimit(float low, float high, float softness, float biasFactor, optional float relaxationFactor);
  void enableAngularMotor(boolean enableMotor, float targetVelocity, float maxMotorImpulse);
};
btHingeConstraint implements btTypedConstraint;

interface btSliderConstraint {
  void btSliderConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Const,Ref] btTransform frameInA, [Const,Ref] btTransform frameInB, boolean useLinearReferenceFrameA);
  void btSliderConstraint([Ref] btRigidBody rbB, [Const,Ref] btTransform frameInB, boolean uesLinearReferenceFrameA);
  void setLowerLinLimit(float lowerLimit);
  void setUpperLinLimit(float upperLimit);
  void setLowerAngLimit(float lowerAngLimit);
  void setUpperAngLimit(float upperAngLimit);
};
btSliderConstraint implements btTypedConstraint;

interface btConstraintSolver {
};

interface btDispatcherInfo {
  attribute float m_timeStep;
  attribute long m_stepCount;
  attribute long m_dispatchFunc;
  attribute float m_timeOfImpact;
  attribute boolean m_useContinuous;
  attribute boolean m_enableSatConvex;
  attribute boolean m_enableSPU;
  attribute boolean m_useEpa;
  attribute float m_allowedCcdPenetration;
  attribute boolean m_useConvexConservativeDistanceUtil;
  attribute float m_convexConservativeDistanceThreshold;
};

interface btCollisionWorld {
  btDispatcher getDispatcher();
  void rayTest([Const, Ref] btVector3 rayFromWorld, [Const, Ref] btVector3 rayToWorld, [Ref] RayResultCallback resultCallback);
  btOverlappingPairCache getPairCache();
  [Ref] btDispatcherInfo getDispatchInfo();
  void addCollisionObject(btCollisionObject collisionObject, optional short collisionFilterGroup, optional short collisionFilterMask);
  [Const] btBroadphaseInterface getBroadphase ();
  void convexSweepTest([Const] btConvexShape castShape, [Const, Ref] btTransform from, [Const, Ref] btTransform to, [Ref] ConvexResultCallback resultCallback, float allowedCcdPenetration);
  void contactPairTest([Const] btCollisionObject colObjA, [Const] btCollisionObject colObjB, [Ref] ContactResultCallback resultCallback);
  void contactTest([Const] btCollisionObject colObj, [Ref] ContactResultCallback resultCallback);
};

interface btContactSolverInfo {
  attribute boolean m_splitImpulse;
  attribute long m_splitImpulsePenetrationThreshold;
};

interface btDynamicsWorld {
  void addAction(btActionInterface action);
  void removeAction(btActionInterface action);
  [Value] btContactSolverInfo getSolverInfo();
};
btDynamicsWorld implements btCollisionWorld;

interface btDiscreteDynamicsWorld {
  void btDiscreteDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration);

  void setGravity([Ref] btVector3 gravity);
  [Value] btVector3 getGravity();

  void addRigidBody(btRigidBody body);
  void addRigidBody(btRigidBody body, short group, short mask);
  void removeRigidBody(btRigidBody body);

  void addConstraint(btTypedConstraint constraint, optional boolean disableCollisionsBetweenLinkedBodies);
  void removeConstraint(btTypedConstraint constraint);

  long stepSimulation(float timeStep, optional long maxSubSteps, optional float fixedTimeStep);
};
btDiscreteDynamicsWorld implements btDynamicsWorld;

[Prefix="btRaycastVehicle::", NoDelete]
interface btVehicleTuning {
  void btVehicleTuning();
  attribute float m_suspensionStiffness;
  attribute float m_suspensionCompression;
  attribute float m_suspensionDamping;
  attribute float m_maxSuspensionTravelCm;
  attribute float m_frictionSlip;
  attribute float m_maxSuspensionForce;
};

interface btVehicleRaycaster {
};

interface btDefaultVehicleRaycaster {
  void btDefaultVehicleRaycaster(btDynamicsWorld world);
};
btDefaultVehicleRaycaster implements btVehicleRaycaster;

[Prefix="btWheelInfo::"]
interface RaycastInfo {
  [Value] attribute btVector3 m_contactNormalWS;
  [Value] attribute btVector3 m_contactPointWS;
  attribute float m_suspensionLength;
  [Value] attribute btVector3 m_hardPointWS;
  [Value] attribute btVector3 m_wheelDirectionWS;
  [Value] attribute btVector3 m_wheelAxleWS;
  attribute boolean m_isInContact;
  attribute any m_groundObject;
};

interface btWheelInfo {
  attribute float m_suspensionStiffness;
  attribute float m_frictionSlip;
  attribute float m_engineForce;
  attribute float m_rollInfluence;
  attribute float m_suspensionRestLength1;
  attribute float m_wheelsRadius;
  attribute float m_wheelsDampingCompression;
  attribute float m_wheelsDampingRelaxation;
  attribute float m_steering;
  attribute float m_maxSuspensionForce;
  attribute float m_maxSuspensionTravelCm;
  attribute float m_wheelsSuspensionForce;
  attribute boolean m_bIsFrontWheel;
  [Value] attribute RaycastInfo m_raycastInfo;
  [Value] attribute btVector3 m_chassisConnectionPointCS;
};

interface btActionInterface {
};

interface btKinematicCharacterController {
  void btKinematicCharacterController(btPairCachingGhostObject ghostObject, btConvexShape convexShape, float stepHeight, optional long upAxis);

  void setUpAxis (long axis);
  void setWalkDirection ([Const,Ref] btVector3 walkDirection);
  void setVelocityForTimeInterval ([Const,Ref] btVector3 velocity, float timeInterval);
  //void reset ();
  void warp ([Const, Ref]btVector3 origin);
  void preStep (btCollisionWorld collisionWorld);
  void playerStep (btCollisionWorld collisionWorld, float dt);
  void setFallSpeed (float fallSpeed);
  void setJumpSpeed (float jumpSpeed);
  void setMaxJumpHeight (float maxJumpHeight);
  boolean canJump ();
  void jump ();
  void setGravity (float gravity);
  float getGravity ();
  void setMaxSlope (float slopeRadians);
  float getMaxSlope ();
  btPairCachingGhostObject getGhostObject ();
  void setUseGhostSweepTest (boolean useGhostObjectSweepTest);
  boolean onGround ();
};
btKinematicCharacterController implements btActionInterface;

interface btRaycastVehicle {
  void btRaycastVehicle([Const, Ref] btVehicleTuning tuning, btRigidBody chassis, btVehicleRaycaster raycaster);
  void applyEngineForce(float force, long wheel);
  void setSteeringValue(float steering, long wheel);
  [Const, Ref] btTransform getWheelTransformWS(long wheelIndex);
  void updateWheelTransform(long wheelIndex, boolean interpolatedTransform);
  [Ref] btWheelInfo addWheel([Const, Ref] btVector3 connectionPointCS0, [Const, Ref] btVector3 wheelDirectionCS0, [Const, Ref] btVector3 wheelAxleCS, float suspensionRestLength, float wheelRadius, [Const, Ref] btVehicleTuning tuning, boolean isFrontWheel);
  long getNumWheels();
  btRigidBody getRigidBody();
  [Ref] btWheelInfo getWheelInfo(long index);
  void setBrake(float brake, long wheelIndex);
  void setCoordinateSystem(long rightIndex, long upIndex, long forwardIndex);
  float getCurrentSpeedKmHour();
};
btRaycastVehicle implements btActionInterface;

interface btGhostObject {
  void btGhostObject();
  long getNumOverlappingObjects();
  btCollisionObject getOverlappingObject(long index);
};
btGhostObject implements btCollisionObject;

interface btPairCachingGhostObject {
  void btPairCachingGhostObject();
};
btPairCachingGhostObject implements btGhostObject;

interface btGhostPairCallback {
  void btGhostPairCallback();
};


// soft bodies

interface btSoftBodyWorldInfo {
  void btSoftBodyWorldInfo();
  attribute float air_density;
  attribute float water_density;
  attribute float water_offset;
  attribute float m_maxDisplacement;
  [Value] attribute btVector3 water_normal;
  attribute btBroadphaseInterface m_broadphase;
  attribute btDispatcher m_dispatcher;
  [Value] attribute btVector3 m_gravity;
};

[Prefix="btSoftBody::"]
interface Node {
  [Value] attribute btVector3 m_x;
};

[Prefix="btSoftBody::"]
interface tNodeArray {
  [Const] long size();
  [Const, Ref] Node at(long n);
};

[Prefix="btSoftBody::"]
interface Material {
  attribute float m_kLST;
  attribute float m_kAST;
  attribute float m_kVST;
  attribute long m_flags;
};

[Prefix="btSoftBody::"]
interface tMaterialArray {
  [Const] long size();
  Material at(long n);
};

[Prefix="btSoftBody::"]
interface Config {
  attribute float kVCF;
  attribute float kDP;
  attribute float kDG;
  attribute float kLF;
  attribute float kPR;
  attribute float kVC;
  attribute float kDF;
  attribute float kMT;
  attribute float kCHR;
  attribute float kKHR;
  attribute float kSHR;
  attribute float kAHR;
  attribute float kSRHR_CL;
  attribute float kSKHR_CL;
  attribute float kSSHR_CL;
  attribute float kSR_SPLT_CL;
  attribute float kSK_SPLT_CL;
  attribute float kSS_SPLT_CL;
  attribute float maxvolume;
  attribute float timescale;
  attribute long viterations;
  attribute long piterations;
  attribute long diterations;
  attribute long citerations;
  attribute long collisions;
};

interface btSoftBody {
  void btSoftBody(btSoftBodyWorldInfo worldInfo);//, long node\_count, [Const] btVector3 x, [Const] long m);

  [Value] attribute Config m_cfg;
  [Value] attribute tNodeArray m_nodes;
  [Value] attribute tMaterialArray m_materials;

  [Const] boolean checkLink( long node0, long node1);
  [Const] boolean checkFace( long node0, long node1, long node2);
  Material appendMaterial();
  void appendNode( [Const, Ref] btVector3 x, float m);
  void appendLink( long node0, long node1, Material mat, boolean bcheckexist);
  void appendFace( long node0, long node1, long node2, Material mat);
  void appendTetra( long node0, long node1, long node2, long node3, Material mat);
  void appendAnchor( long node, btRigidBody body, boolean disableCollisionBetweenLinkedBodies, float influence);
  [Const] float getTotalMass();
  void setTotalMass( float mass, boolean fromfaces);
  void setMass(long node, float mass);
  void transform( [Const, Ref] btTransform trs);
  void translate( [Const, Ref] btVector3 trs);
  void rotate( [Const, Ref] btQuaternion rot);
  void scale(  [Const, Ref] btVector3 scl);
  long generateClusters(long k, optional long maxiterations);
  btSoftBody upcast([Const] btCollisionObject colObj);
};
btSoftBody implements btCollisionObject;

interface btSoftBodyRigidBodyCollisionConfiguration {
  void btSoftBodyRigidBodyCollisionConfiguration([Ref] optional btDefaultCollisionConstructionInfo info);
};
btSoftBodyRigidBodyCollisionConfiguration implements btDefaultCollisionConfiguration;

interface btSoftBodySolver {
};

interface btDefaultSoftBodySolver {
  void btDefaultSoftBodySolver ();
};
btDefaultSoftBodySolver implements btSoftBodySolver;

interface btSoftBodyArray {
  [Const] long size();
  [Const] btSoftBody at(long n);
};

interface btSoftRigidDynamicsWorld {
  void btSoftRigidDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration, btSoftBodySolver softBodySolver);

  void addSoftBody(btSoftBody body, short collisionFilterGroup, short collisionFilterMask);
  void removeSoftBody(btSoftBody body);
  void removeCollisionObject(btCollisionObject collisionObject);

  [Ref] btSoftBodyWorldInfo getWorldInfo();
  [Ref] btSoftBodyArray getSoftBodyArray();
};
btSoftRigidDynamicsWorld implements btDiscreteDynamicsWorld;

interface btSoftBodyHelpers {
  void btSoftBodyHelpers();

  btSoftBody CreateRope([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 from, [Const, Ref] btVector3 to, long res, long fixeds);
  btSoftBody CreatePatch([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 corner00, [Const, Ref] btVector3 corner10, [Const, Ref] btVector3 corner01, [Const, Ref] btVector3 corner11, long resx, long resy, long fixeds, boolean gendiags);
  btSoftBody CreatePatchUV([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 corner00, [Const, Ref] btVector3 corner10, [Const, Ref] btVector3 corner01, [Const, Ref] btVector3 corner11, long resx, long resy, long fixeds, boolean gendiags, float[] tex_coords);
  btSoftBody CreateEllipsoid([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 center, [Const, Ref] btVector3 radius, long res);
  btSoftBody CreateFromTriMesh([Ref] btSoftBodyWorldInfo worldInfo, float[] vertices, long[] triangles, long ntriangles, boolean randomizeConstraints);
  btSoftBody CreateFromConvexHull([Ref] btSoftBodyWorldInfo worldInfo, [Const] btVector3 vertices, long nvertices, boolean randomizeConstraints);
};

\end{lstlisting}